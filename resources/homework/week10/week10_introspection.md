## 做题反思

### 盛最多水的容器(P11_ContainerWithMostWater)

1. 本质判断长版的移动不会造成面积的变大,因此我们可以得出结论只需要移动短板,然后比最大就可以饿了;
2. 的确速度变快了很多;

### 12-整数转罗马数字 P12_IntegerToRoman

1. 我自己还是使用数字求余这一套,也做的出来,就是边界条件比较多
2. 由于这个题目可能的不多,因此也可以通过枚举所有的数,然后求减法得出.注意通过while确保可以一直减到小于当前数;
3.

### 300最长子序列 P300_LongestIncreasingSubsequence

1. 第二次做了,基本能搞定DP.

### 20-有效的括号 P20_ValidParentheses

1. 符号判断,使用栈比较简单
2. 不过最开始使用equal一个个判断,使用map的方法判断扩展性好一些.值得学习;

### 146-LRU 缓存机制 P146_LruCache_Use_Link_HashMap

1. 首先这里偷个懒,用java原生的LRU工具,但是由于Java原生的是插入后删除,与这边的删除后插入不一样,造成空间浪费多一些,因为为了避免扩容,直接一开始就给2倍的容量吧;
2. 实际上linkHashMap没有考虑并发,工业上没办法用来做缓存用,在工业上使用的是,guavaCache以及java 8使用的caffeine;后者不仅升级jdk,还是用新的算法优化缓存;
3. 最后自己在用简单的链表+map实现一遍吧,这里get需要更新位置比较费性能,如果自己实现queue可以优化
4. 还想到一个优先级队列,这里就不尝试了