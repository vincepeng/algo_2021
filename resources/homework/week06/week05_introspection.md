## 做题反思

### 64-最小路径和(P64_MinimumPathSum)

1. 这个题主要是边界判断不确定,后面看题解还真是这么简单的判断就行了
2. 第一次用动态规划,挺好玩的.按照三步走,1.重复步骤;2.位置值;3.动态公式;

### 322-零钱兑换(P322_CoinChange)

1. 动态规划还是有点难,主要是写动态方程的抽象方式,这里是反推的方式进行生成的.用金额作为key,次数反而作为value了.
2. 这里使用较原值大的数进行填充的也巧妙,因为amount是已知的,
3. 使用一个迭代进行持续比大小也比较大胆,值得记录这种用法

### 198-打家劫舍( P198_HouseRobber)

1. 按照标准来,这个还比较简单,大概用时间10来分钟;
2. 动态规划三步走,再重复一遍:
   1. 子结构最优表达式:opt[n]=bestOf(opt{1...n})
   2. 储存中间状态:opt[i]
   3. 递推公式:状态转移方程或者dp方程;

### 589-N 叉树的前序遍历(P589_NAryTreePreorderTraversal)

1. 使用遍历方法,用时大概30分钟,主要还是树的遍历写的不熟悉,没办法行云流水,每次写还需要思考边界条件,解决办法是熟能生巧吧
2. root没有判空,按照递减排列,i用了i++,浪费了点时间,解决办法是多记录错误,下次避免.

### 590-N 叉树的后序遍历(P590_NAryTreePostorderTraversal)

1. 顺便将后续遍历也做了,不过想得太复杂,用时稍多,不满意,下次再做一遍;

### 363-矩形区域不超过 K 的最大数值和(P363_MaxSumOfRectangleNoLargerThanK)

1. 这道题真是复杂,还需要结合以前只是,将二维变为一维
2. 边界条件太多,容易搞错;

### 704-二分查找 P704_BinarySearch

1. 简单做了二分查找,边界条件没处理好,下次记得做点用例测试一下;


