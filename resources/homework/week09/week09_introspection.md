## 做题反思

### //387-字符串中的第一个唯一字符(P387_FirstUniqueCharacterInAString)

1. 使用面向对象的方法做的.不过面向对象空间占用较多一些.因为需要放对象的头指正,以及指针压缩.数据量大的时候没有数组好;

### 62-不同路径(P62_UniquePaths)

1. 这个是典型的动态规划题目,使用二维矩阵10几分钟就能作出来
2. 比较好的时候使用了一个dump row,往外扩展了一行和一列就不用考虑边界问题了;
3. 后面箱节约空间挺麻烦了,考虑了蛮久,主要是边界条件不好确定,意思到时懂,可以复用dp[n]的空间,后面看LeetCode的内存,就节约了100k o(╯□╰)o

### 415-字符串相加 P415_AddStrings

1. 这个题目本来很简单,但是实现方法做的太复杂,主要是没有使用字符串的reverse方法;
2. 这里面有几个知识需要死记硬背一下.char转化为int,使用a-'0';
3. 对于相加%,/两个结合,而且使用字符串翻转会简单很多;
4. carry=1的时候需要注意可能已经有进位,所以需要特殊处理一下,避免有进位没有处理;
5. 这个题目是快手的一面面试题

### 300-最长递增子序列 P300_LongestIncreasingSubsequence

1. 第一时间想到了dp,但是没想到这么做转移方程,很巧妙呀.
2. 还是按照转移方程的三步走:重复单元,中间状态,转移方程;

### //8-字符串转换整数 (atoi) P8_StringToIntegerAtoi

1. 我是真么想到这个边界调节好多 2.有几个方法是沉淀下来了.如何防范越界问题,如何处理符号位问题,如何处理前置0 问题,以及如何计算字符串的数字值,正负数的处理逻辑
2. 特别地要注意移位后,要时刻判断是否到字符串末尾了;
3. 特别地,为了考研自己处理溢出的问题,特别避免了使用long类型来存储结果;
4. 状态机太巧秒了.这个题在头条这么高频估计也是这个原因吧!.

分治如果淘汰次有子结构,就是动态规划. 1.拆分子问题; 2.分治+最优子结构; 3.动态地推;