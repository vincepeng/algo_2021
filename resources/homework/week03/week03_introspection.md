## 做题反思

### 189 旋转数组(P189_RotateArray)

1. 自己思考太久,不利于快速掌握大量题目;
2. 替换法时对分界点思考太久,画个图就知道就是K作为分界点;
3. 使用ArrayList最方便,不容易出错.在没有限制条件下优先使用成熟API;

### 频率统计

1. compare一定要统计全,否则会违反约束,使用compareTo方法就很好用
2. java stream的limit\sort\sort(collection.revers)\

### 最近公共祖先

1. 一般树的遍历都是传进去list的,这个遍历是巧妙返回当前值;
2. 树的递归,天然有先的范围最小,因此最小找到的就是最近的;
3. 叶子节点的终结使用的是left和right都为空来判断
4. 递归还有一层语义,就是拿到这个值就返回,这里由于唯一性也巧妙保证了找到后其它遍历返回一定会为空

### 丑数(264-Ugly Number II)

1. 比较难的是思考底层数学规律的连续性,我发现题解都没有说,把它当成理所当然,自己思考了较久. 例如2,3,5,其中2可能会用两次才会用5.2,3,2^2(4),5.因此单纯乘以n并没有保证一定有4放入队列.我怎们能保证 到5取数的时候,4一定放入队列中呢?
   这里刚好有点巧妙的是,我们以2会出现两次,但是我们有3个数,第一次4不会在里面,但是第二次迭代一定会有4,况且还有第三次,因此3次遍历一定会确保2*2会被放入其中.
2. 没有考虑到int溢出问题;

### 层序遍历 (429-N-ary Tree Level Order Traversal)[]

1. 通过父node来递归更好,代码优雅些
2. 遍历一定要判断root为空.
3. 广度优先优先使用遍历

## 综合能力反思

1. 发现LeetCode的插件可以稍微配置下,发现晚了,下次装完插件可以搜索说明,避免一开始就使用;
2. 反思每天都谢谢有助与进步;
3. 跟上班级节奏,每天做1-3到算法题目,有助于思考;
